{"ast":null,"code":"import _objectSpread from \"/Users/Kim/Desktop/todolist5/client/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\n\n// gets max xPos of the string that is above the current one\nfunction get_xPos(list, cursor) {\n  cursor.yPos -= 1;\n\n  if (cursor.yPos < 0) {\n    cursor.yPos = 0;\n    return cursor;\n  }\n\n  let text = list[cursor.yPos].text;\n  cursor.xPos = text.length - 1;\n  return cursor;\n}\n\nexport function begOfPrevWord(list, cursor) {\n  cursor.savePos = -1;\n\n  const oldCursor = _objectSpread({}, cursor);\n\n  let text = list[cursor.yPos].text; //get the str before the coursor and reverse it\n\n  let reversedStr = text.substring(0, cursor.xPos);\n  reversedStr = reversedStr.split(\"\").reverse().join('');\n\n  if (cursor.xPos <= 0) {\n    if (cursor.yPos === 0) {\n      cursor.xPos = 0;\n      return cursor;\n    }\n\n    cursor.yPos -= 1;\n    text = list[cursor.yPos].text;\n    if (!text.length) cursor.xPos = 0;\n    let index = text.split(\"\").reverse().join('').indexOf(\" \");\n    cursor.xPos = index >= 0 ? text.length - index : 0;\n    return cursor;\n  } // try to match a character and space after each other then set the position on the character\n\n\n  let regex = /\\w[\\s]/;\n  let index = reversedStr.search(regex);\n  cursor.xPos = cursor.xPos - index - 1; // if no change that indicates that we are on the first word of the line\n\n  if (oldCursor.xPos === cursor.xPos) {\n    if (oldCursor.xPos === 0) {\n      return get_xPos(list, cursor);\n    }\n\n    cursor.xPos = 0;\n  }\n\n  return cursor;\n}\nexport default {\n  begOfPrevWord\n};","map":{"version":3,"sources":["/Users/Kim/Desktop/todolist5/client/src/components/todo/cursor/begOfPrevWord.js"],"names":["get_xPos","list","cursor","yPos","text","xPos","length","begOfPrevWord","savePos","oldCursor","reversedStr","substring","split","reverse","join","index","indexOf","regex","search"],"mappings":";;AACA;AACA,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,MAAxB,EAA+B;AAC7BA,EAAAA,MAAM,CAACC,IAAP,IAAe,CAAf;;AACA,MAAID,MAAM,CAACC,IAAP,GAAc,CAAlB,EAAqB;AACnBD,IAAAA,MAAM,CAACC,IAAP,GAAc,CAAd;AACA,WAAOD,MAAP;AACD;;AAL4B,MAOxBE,IAPwB,GAOhBH,IAAI,CAACC,MAAM,CAACC,IAAR,CAPY,CAOxBC,IAPwB;AAQ7BF,EAAAA,MAAM,CAACG,IAAP,GAAcD,IAAI,CAACE,MAAL,GAAc,CAA5B;AACA,SAAOJ,MAAP;AACD;;AAED,OAAO,SAASK,aAAT,CAAuBN,IAAvB,EAA6BC,MAA7B,EAAoC;AACzCA,EAAAA,MAAM,CAACM,OAAP,GAAiB,CAAC,CAAlB;;AACA,QAAMC,SAAS,qBAAOP,MAAP,CAAf;;AAFyC,MAGpCE,IAHoC,GAG5BH,IAAI,CAACC,MAAM,CAACC,IAAR,CAHwB,CAGpCC,IAHoC,EAKzC;;AACA,MAAIM,WAAW,GAAGN,IAAI,CAACO,SAAL,CAAgB,CAAhB,EAAmBT,MAAM,CAACG,IAA1B,CAAlB;AACAK,EAAAA,WAAW,GAAGA,WAAW,CAACE,KAAZ,CAAkB,EAAlB,EAAsBC,OAAtB,GAAgCC,IAAhC,CAAqC,EAArC,CAAd;;AAEA,MAAIZ,MAAM,CAACG,IAAP,IAAe,CAAnB,EAAqB;AACnB,QAAIH,MAAM,CAACC,IAAP,KAAgB,CAApB,EAAsB;AACpBD,MAAAA,MAAM,CAACG,IAAP,GAAc,CAAd;AAAiB,aAAOH,MAAP;AAAgB;;AAGnCA,IAAAA,MAAM,CAACC,IAAP,IAAe,CAAf;AACAC,IAAAA,IAAI,GAAGH,IAAI,CAACC,MAAM,CAACC,IAAR,CAAJ,CAAkBC,IAAzB;AACA,QAAI,CAACA,IAAI,CAACE,MAAV,EACEJ,MAAM,CAACG,IAAP,GAAc,CAAd;AACF,QAAIU,KAAK,GAAGX,IAAI,CAACQ,KAAL,CAAW,EAAX,EAAeC,OAAf,GAAyBC,IAAzB,CAA8B,EAA9B,EAAkCE,OAAlC,CAA0C,GAA1C,CAAZ;AACAd,IAAAA,MAAM,CAACG,IAAP,GAAeU,KAAK,IAAI,CAAV,GAAeX,IAAI,CAACE,MAAL,GAAcS,KAA7B,GAAqC,CAAnD;AACA,WAAOb,MAAP;AACD,GArBwC,CAuBzC;;;AACA,MAAIe,KAAK,GAAG,QAAZ;AACA,MAAIF,KAAK,GAAGL,WAAW,CAACQ,MAAZ,CAAoBD,KAApB,CAAZ;AACAf,EAAAA,MAAM,CAACG,IAAP,GAAcH,MAAM,CAACG,IAAP,GAAcU,KAAd,GAAsB,CAApC,CA1ByC,CA4BzC;;AACA,MAAIN,SAAS,CAACJ,IAAV,KAAmBH,MAAM,CAACG,IAA9B,EAAoC;AAClC,QAAII,SAAS,CAACJ,IAAV,KAAmB,CAAvB,EAAyB;AACvB,aAAOL,QAAQ,CAACC,IAAD,EAAOC,MAAP,CAAf;AACD;;AACDA,IAAAA,MAAM,CAACG,IAAP,GAAc,CAAd;AACD;;AACD,SAAOH,MAAP;AACD;AAED,eAAe;AACbK,EAAAA;AADa,CAAf","sourcesContent":["\n// gets max xPos of the string that is above the current one\nfunction get_xPos(list, cursor){\n  cursor.yPos -= 1;\n  if( cursor.yPos < 0 ){\n    cursor.yPos = 0;\n    return cursor;\n  }\n\n  let {text} = list[cursor.yPos];\n  cursor.xPos = text.length - 1;\n  return cursor\n}\n\nexport function begOfPrevWord(list, cursor){\n  cursor.savePos = -1;\n  const oldCursor = {...cursor};\n  let {text} = list[cursor.yPos];\n\n  //get the str before the coursor and reverse it\n  let reversedStr = text.substring( 0, cursor.xPos );\n  reversedStr = reversedStr.split(\"\").reverse().join('');\n\n  if( cursor.xPos <= 0){\n    if( cursor.yPos === 0){\n      cursor.xPos = 0; return cursor; } \n\n\n    cursor.yPos -= 1;\n    text = list[cursor.yPos].text;\n    if( !text.length ) \n      cursor.xPos = 0;\n    let index = text.split(\"\").reverse().join('').indexOf(\" \");\n    cursor.xPos = (index >= 0) ? text.length - index : 0;\n    return cursor;\n  }\n\n  // try to match a character and space after each other then set the position on the character\n  let regex = /\\w[\\s]/;\n  let index = reversedStr.search( regex );\n  cursor.xPos = cursor.xPos - index - 1;\n  \n  // if no change that indicates that we are on the first word of the line\n  if( oldCursor.xPos === cursor.xPos ){\n    if( oldCursor.xPos === 0){\n      return get_xPos(list, cursor);\n    }\n    cursor.xPos = 0;\n  }\n  return cursor;\n}\n\nexport default {\n  begOfPrevWord,\n}"]},"metadata":{},"sourceType":"module"}